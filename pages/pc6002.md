---
layout: page
title: "Al-Warka PC-6002 Reference"
description: ""
---
{% include JB/setup %}

[mode6screen2_rects_gif]: {{site.baseurl}}assets/photos/pc6002/mode6screen2_rects.gif
[mode6screen3_rects_gif]: {{site.baseurl}}assets/photos/pc6002/mode6screen3_rects.gif
[colorpalette]: {{site.baseurl}}assets/photos/pc6002/pc60_palette_numbers.gif
[colorpalette_m5s4]: {{site.baseurl}}assets/photos/pc6002/pc60_palette_m5s4.gif
[colorpalette_m6s3]: {{site.baseurl}}assets/photos/pc6002/pc60_palette_m6s3.gif

Work in Progress

# General
{: #general}

## Color Palette
{: #colorPalette}

The PC-60 and for Mode 5 (text and screen 3) and Mode 6 (text and screen 2), full 16-color screen modes use this palette:

![colorpalette]

**COLOR**|**RGB**
:-----:|:-----:
1|0xFF101410
2|0xFFAD00FF
3|0xFFFFAE00
4|0xFFFF00AD
5|0xFF00FFAD
6|0xFF00AEFF
7|0xFFADFF00
8|0xFFADAEAD
9|0xFF101410
10|0xFF0000FF
11|0xFFFF0000
12|0xFFFF00FF
13|0xFF00FF00
14|0xFF00FFFF
15|0xFFFFFF00
16|0xFFFFFFFF

Mode 5 Screen 4 uses this 4 color palette:

![colorpalette_m5s4]

Mode 6 Screen 3 uses this 4 color palette:

![colorpalette_m6s3]

--------------------------

# MODE 5 
{: #mode5}

## Memory Map 
{:# #mode5memmap}

### SCREEN/PAGE memory addresses

8 pixels block per byte-pair.

Size of each buffer is: 1 byte * 40 * 200 = 8000 byte or 0x1f40 byte

|-----------+---------------+-------------------+-------------------+-------------------|
| PAGE mode | PAGE 1 (text) | PAGE 2 (graphics) | PAGE 3 (graphics) | PAGE 4 (graphics) |
|-----------|:-------------:|:-----------------:|:-----------------:|:-----------------:|
| 3 Pages   | ??            | 0x4000 + 0x6000   | 0x0000 + 0x2000   |                   |
| 4 Pages   | ??            | 0x8000 + 0xa000   | 0x4000 + 0x6000   | 0x0000 + 0x2000   |
|-----------+---------------+-------------------+-------------------+-------------------|

### SCREEN 3 Colors

Screen 3 is actually 160x200 mapped to 320x200 so each pixel is a horizontal 2 pixels.

Each 4 horizontal-pixel (or 8 pixels) are stored in 2 bytes, one in page address and one in page address + 0x2000:

    ADR = &H2000
    ATR = &H4000

The color of the 4 horizontal-pixels is determined by the combination of both ADR and ATR bytes for those pixels. ATR is the high byte and ADR is the low byte:

|-----------------------------|
|     | P0  | P1  | P2  | P3  |
|-----|:---:|:---:|:---:|:---:|
| ATR | 0 0 | 0 0 | 0 0 | 0 0 |
| ADR | 0 0 | 0 0 | 0 0 | 0 0 |
|-----------------------------|
|-----------------------------|

------------------------
# MODE 6 
{: #mode6}

## Memory Map
{:# #mode5memmap}

### SCREEN 2 (320x200)

Divided into two segments in memory, 1 byte maps directly to 2 pixel colors, 16 colors palette.

- Right rect/segment is a 64x200 mapped to memory: 0x0000 to 0x18ff
    - 1 horizontal line size = 32 bytes
- Left rect/segment is a 256x200 mapped to memory: 0x1a00 to 0x7dff
    - 1 horizontal line size = 128 bytes

![mode6screen2_rects_gif]

Bytes are arranged in groups of 4 pixels, two top and two bottom so the layout is linear in blocks of 4 pixels (2 bytes) otherwise doing single-pixel operations correctly is a bit tricky and requires some number juggling:

|---------+--------------+--------------|
| MEMORY  | Low 4-bit    | High 4-bit   |
|---------|--------------+--------------|
| Byte 0  | Pixel 0      | Pixel 1      |
| Byte 1  | Pixel 2      | Pixel 3      |
|---------------------------------------|


### SCREEN 3 (640x200)

Divided into two segments in memory, 1 byte maps directly to 4 pixel colors, 4 colors palette.

- Right rect/segment is a 64x200 mapped to memory: 0x0000 to 0x18ff
    - 1 horizontal line size = 32 bytes
- Left rect/segment is a 256x200 mapped to memory: 0x1a00 to 0x7dff
    - 1 horizontal line size = 128 bytes

![mode6screen3_rects_gif]

--------------------------

# N66/SR BASIC
{: #basic}

## N66/SR BASIC Commands
{: #basicCommands}

|----------------------------------------|
ABS|AND|ASC|ATN|ATTR$|AUTO|BEEP|[BGM](#basic_BGM)
BLOAD|BSAVE|[CDBL](#basic_CDBL)|[CHAIN](#basic_CHAIN)|CHR$|CIRCLE|CLEAR|CLOAD
CLOSE|CLS|CMD|COLOR|COM|COMMON|CONSOLE|CONT
CSAVE|CSNG|CSRLIN|CVD|CVS|DATA|DATE$|DEF
DEFDBL|DEFINT|DEFSNG|DEFSTR|DELETE|DIM|DSKF|DSKI$
DSKO$|END|EOF|EQV|ERASE|ERL|ERR|ERROR
EXEC|EXP|FIELD|FILES|FIX|FN|FOR|FPOS
FRE|GET|GOSUB|GOTO|GRP$|HEX$|IF|IMP
INKEY$|INPUT|INSTR|INT|KANJI|KEY|KILL|LCOPY
LEFT$|LEN|LET|LFILES|LFO|LINE|LIST|LLIST
LOAD|LOCATE|LOF|LOG|LPOS|LPRINT|LSE|LSET
MAP|MENU|MERGE|MID$|MKD$|MKI$|MOD|MON
MOTOR|NAME|NEW|NEXT|NOT|OCT$|OFF|ON
OPEN|OR|OUT|PAINT|[PALET](#basic_PALET)|PEEK|PEN|PLAY
POINT|POKE|POS|PRESET|PRINT|PSET|PUT|READ
REM|RENUM|RESTORE|RESUME|RETURN|RIGHT$|ROLL|RSET
RUN|SAVE|SCREEN|SEARCH|SET|SIN|SOUND|SPC(
SQR|SRQ|STEP|STICK|STOP|STR$|STRIG|STRING$
SWAP|TAB(|TALK|TAN|TERM|THEN|TIME|TO
TROFF|TRON|USING|USR|VARPTR|VIEW|WAIT|WEND
WHILE|WIDTH|WINDOW|XOR

--------------------------

## N66/SR BASIC Reference (WIP)
{: #basicReference}

--------------------------

## System Commands
{: #basicReference_System}

### FRE(arg)
{: #basic_FRE}

Returns amount of unused available memory in bytes.

Usage: 

FRE("") -> Available string space. (300 on mode 6 startup)

FRE(number) -> Available unused memory in bytes.

Example:

~~~ vb
PRINT "Available string memory = " ; FRE("") ; " characters"
PRINT "Unused memory = " ; FRE(0) ; " bytes"
~~~

--------------------------

## Unknown Commands
{: #basicReference_Unknown}

### BGM
{: #basic_BGM}

BGM takes a number as argument, could be 0 or 1.

Based on how [BGM is implemented in SmileBasic](http://smilebasic.com/en/reference/#sound) it might be meant to store music notation strings to replay them anytime?

Example:

~~~ vb
BGM 0
~~~

--------------------------

## Not Available Commands
{: #basicReference_NotAvailable}

If you attempt to use these commands you'll get an "?NA Error" (Not Available Error).

According to the [some of the same commands in MSX BASIC](https://www.msx.org/wiki/ATTR$() ), these commands point to an empty location in memory allowing diversion to custom code.

### ATTR$()
{: #basic_ATTR}

**Not Implemented**

This was meant to return disk drive attributes.

### CDBL
{: #basic_CDBL}

**Not Implemented**

Casts an integer or single precision number to double precision.

### CINT
{: #basic_CINT}

**Not Implemented**

Casts a single or double precision number to integer.

### CSNG
{: #basic_CSNG}

**Not Implemented**

Casts an integer or double precision number to single precision.

### CHAIN
{: #basic_CHAIN}

**Not Implemented**

### CMD
{: #basic_CMD}

**Not Implemented**

### COM
{: #basic_COM}

**Not Implemented**

### INSTR
{: #basic_INSTR}

**Not Implemented**

### LFO
{: #basic_LFO}

**Not Implemented**

### MAP
{: #basic_MAP}

**Not Implemented**

### PALET
{: #basic_PALET}

Allows modifying the color palette in MODE 6 SCREEN 3. For this mode, the palette is assigned to color entries: 13, 14, 15, 16

![colorpalette_m6s3]

~~~ vb
PALET A, B
~~~

* A: palette entry to change, can be: 13, 14, 15, 16
* B: color of choice for entry A, can be any color from: 1 to 16

Example: change color 1 to red:

~~~ vb
PALET 13,11
~~~

### SEARCH
{: #basic_SEARCH}

**Not Implemented**

### SET
{: #basic_SET}

**Not Implemented**

### SRQ
{: #basic_SRQ}

**Not Implemented**

### TERM
{: #basic_TERM}

**Not Implemented**

### VARPTR
{: #basic_VARPTR}

**Not Implemented**


### VIEW
{: #basic_VIEW}

**Not Implemented**

### WINDOW
{: #basic_WINDOW}

**Not Implemented**

### WEND
{: #basic_WEND}

**Not Implemented**

--------------------------

#### COMMON

#### DEFDBL

#### DEFINT

#### DEFSNG

#### DEF FN

#### DEF 

#### DSKF

#### DSKI$

#### DSKO$

#### EQV

#### ERASE

#### FIX

#### GRP$

#### IMP

#### LOF

#### LSE

#### MID$

#### MKD$

#### MKI$

#### PALET

#### RSET

#### SPC(

#### STRING$

#### TAB(

#### USR

#### WAIT
