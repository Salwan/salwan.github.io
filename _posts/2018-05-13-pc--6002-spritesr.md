---
layout: post
title:  "PC-6002 Sprites Library: SPRITESR"
description: "PC-6002 SPRITESR Version 1"
category: pc-6002
tags: [pc-6001,pc-6002,Warka,z80,retro]
published: true
---

{% include JB/setup %}

[vram_pixelblock_layout]: {{site.baseurl}}assets/photos/pc6002/vram_pixelblock_layout.gif "VRAM Pixel Blocks Layout"

[SPRITESR git]: https://github.com/Salwan/pc6002/tree/master/SPRITESR "PC-6002 Git Repo: SPRITESR"

[SPRITESR git](SPRITESR) is a work-in-progress sprite library to automate drawing and animating sprites. SPRITESR is written to work specifically with N66 SR Mode 6 Screen 2 (Warka PC-6002, NEC PC6001 Mk2 SR, NEC PC-6601 SR, and NEC Mr PC).

<video width="640" height="480" autoplay>
  <source src="{{site.baseurl}}assets/videos/spritesr_1.webm" type="video/webm">
Your browser does not support the video tag or webm videos.
</video> 

[SPRITESR git](Git Repository Here.)

### Features

SPRITESR provides 8 sprite slots that auto-redraw on VSYNC at half rate (30 fps).

Sprites coordinates can be dynamically updated and actual bitmap data can be changed to allow multi-frame animations.

SPRITESR works best for 8x8 pixels sprites but there is no hard limit, it can draw any size of sprite defined with two conditions: height must be divisible by 2, and width must be divisible by 4. 

However for larger than 8x8 sprites flicker may occur.

SPRITESR allows specifying which sprites were changed this frame by calling the procedure SPRITESR_SETREDRAW. It will only fully redraw changed sprites and skip clearing unchanged sprites (useful for minimizing flicker slightly).

### Modules 

The library is currently made up of the following modules:

* n66sr_bios.asm: definitions for a number of N66 SR BIOS calls (addresses) and useful system constants.
* vsync.asm: vsync user event setup utility.
* fastclear.asm: fast screen 2 clearing procedures covering all 3 areas of VRAM.
* spritesr.asm: fast sprite drawing in direct VRAM accessible rectangle in screen 2 which starts at 0, 12 and has width/height of 256x188. PNG60 was updated with new functionality to support exporting p6bmp binaries directly usable by SPRITESR.

The demo is made up of the following modules:

* picard.asm: actual demo code setting up all sprites, reading input, and updating sprites accordingly.
* sprites.asm: definitions for a number of test sprites with different sizes.

### Implementation Details

SPRITESR is currently written entirely in z80 assembly and doesn't make use of COMPILE60 tool yet.

I went through multiple attempts to implement fast sprites, for the life of me I still can't figure out what's wrong with VRAM in SR screen 2.. for some reason writing directly to rectangular area 0,0 to 255,11 or 256,0 to 320,200 just produces garbage despite the memory map clearly being marked for those areas in all information I found.

The VRAM layout is also odd. Each 2 horizontal pixels are directly equal to 1 byte but these pairs of pixels are arranged in 8 pixel blocks (4 bytes of memory) representing 4x2 pixels on screen:

![vram_pixelblock_layout]

When drawing sprites, rather than doing it pixel by pixel it's done by block where every 4x2 pixels make 1 block which means width and height of sprites must be divisible by 4x2.

This produces very fast drawing approaching hardware sprites performance although things get costly quickly the larger the sprites get. As a consequence of drawing blocks of pixels the animation must be done in steps of 2 pixels for both horizontal and vertical movement.

For the garbage areas at the top and right there are two ways to write pixels to the correctly:

1. Output Y coordinate to 2 special ports: 0xce (low) and 0xcf (high) and read/write pixels from/to X coordinate 0 to 320 mapped directly to address 0x0000.
2. View screen 1 (text screen) and set screen 2 as work area. When writing data directly to screen 2 vram in this case it works flawlessly but you can't see screen 2 in the meantime so this isn't useful.

First method always works perfectly but is noticeably slower as 2 bytes need to be output for every horizontal line.

### Limitations:

- Due to how VRAM in SR screen 2 work, sprites are limited to rectangular area starting at 0, 12 with width/height = 256x188.
- Sprites are cleared using background color specified, meaning the background must be a solid color.
- Sprite overlap is problematic as background clearing will overwrite sprite pixels below.
- No transparency is supported.
- Sprite movement horizontally and vertically can only be 2 pixels at a time due to the VRAM layout.

### Planned Features

- Allow supporting simple dithered background clear colors.
- Attempt implementing some sort of transparency with minimal performance impact.
- Implement simple overlap detection between user-marked sprites.
- Simple tile map support, each tile is 16x16 pixels and may be used for clearing sprite backgrounds if performance impact was acceptable.
- Tile map scrolling support using the ROLL hardware scroller available in SR, single direction only horizontal or vertical.
